/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface ChineseSearchDocument {
  /** 文档唯一 ID */
  id: string
  /** 标题（可选） */
  title?: string
  /** 内容 */
  content: string
  /** 标签列表（可选） */
  tags?: Array<string>
  /** 元数据 JSON（可选） */
  metadata?: string
}
export interface ChineseSearchResult {
  id: string
  title?: string
  content: string
  tags?: Array<string>
  metadata?: string
  score: number
}
export interface ChineseSearchStats {
  documentCount: number
}
export interface KeywordResult {
  keyword: string
  weight: number
}
/** 使用 jieba 分词（独立函数） */
export declare function jiebaCut(text: string, searchMode?: boolean | undefined | null): Array<string>
/** 提取关键词（独立函数） */
export declare function jiebaExtractKeywords(text: string, topK?: number | undefined | null): Array<KeywordResult>
/** 文本块 */
export interface TextChunk {
  /** 块内容 */
  content: string
  /** 在原文中的起始字节偏移 */
  startOffset: number
  /** 在原文中的结束字节偏移 */
  endOffset: number
  /** 字符数 */
  charCount: number
  /** 块索引 */
  index: number
}
/** 批量分块结果 */
export interface ChunkBatchResult {
  /** 文档索引 */
  docIndex: number
  /** 分块列表 */
  chunks: Array<TextChunk>
}
/** 分块器配置 */
export interface ChunkerConfig {
  maxChunkSize: number
  overlapSize: number
  separators: Array<string>
}
/** 快速分块 (使用默认配置) */
export declare function quickChunk(text: string, maxSize?: number | undefined | null, overlap?: number | undefined | null): Array<TextChunk>
/** 估算 token 数量 */
export declare function estimateTokenCount(text: string): number
/** 标签共现关系 */
export interface TagCooccurrence {
  /** 源标签 */
  tag1: string
  /** 目标标签 */
  tag2: string
  /** 共现权重 (0-1) */
  weight: number
  /** 共现次数 (权重 * 100 的近似值) */
  count: number
}
/** 标签信息 */
export interface TagInfo {
  /** 标签 ID */
  id: string
  /** 标签名称 */
  name: string
  /** 出现频率 */
  frequency: number
}
/** 文档输入（用于构建共现矩阵） */
export interface DocumentInput {
  /** 文档 ID */
  id: string
  /** 文档包含的标签列表 */
  tags: Array<string>
}
export interface MemoryRecord {
  id: string
  content: string
  embedding?: Array<number>
  tags?: Array<string>
  importance?: number
  createdAt?: string
  updatedAt?: string
  metadata?: string
}
export interface MemoryQuery {
  text?: string
  tags?: Array<string>
  minImportance?: number
  limit?: number
}
export interface TraceLog {
  traceId: string
  spanId?: string
  parentSpanId?: string
  operation: string
  level: string
  message?: string
  metadata?: string
  durationMs?: number
  createdAt?: string
}
export interface TraceQuery {
  traceId?: string
  level?: string
  operation?: string
  limit?: number
}
export interface DatabaseStats {
  memoryCount: number
  knowledgeCount: number
  diaryCount: number
  tagCount: number
  traceCount: number
  fileSizeBytes: number
  path: string
}
export interface DiaryRecord {
  id: string
  date: string
  content: string
  tags?: Array<string>
  embedding?: Array<number>
  bookName: string
  createdAt?: string
  updatedAt?: string
}
export interface DiaryDateQuery {
  startDate?: string
  endDate?: string
  bookName?: string
  limit?: number
}
export interface DiarySearchQuery {
  keyword: string
  bookName?: string
  limit?: number
}
export interface DiaryBookInfo {
  bookName: string
  entryCount: number
  latestDate?: string
}
export interface DiaryStats {
  totalEntries: number
  totalWords: number
  firstEntryDate?: string
  lastEntryDate?: string
  topTags: Array<TagCount>
  bookName?: string
}
export interface TagCount {
  tag: string
  count: number
}
export interface ScheduledTask {
  id: string
  name: string
  taskType: string
  cronExpression?: string
  enabled?: boolean
  payload?: string
  priority?: number
  maxRetries?: number
  timeoutMs?: number
  createdAt?: string
  updatedAt?: string
}
export interface TaskExecutionLog {
  id: number
  taskId: string
  taskName: string
  startedAt: string
  endedAt?: string
  status: string
  result?: string
  error?: string
  durationMs?: number
  retryCount?: number
}
export interface TaskLogQuery {
  taskId?: string
  status?: string
  limit?: number
}
export interface TaskStats {
  taskId?: string
  totalExecutions: number
  successfulExecutions: number
  failedExecutions: number
  averageDurationMs: number
  lastExecution?: string
}
/** 搜索结果项 (输入) */
export interface SearchResultItem {
  /** 文档 ID */
  id: string
  /** 文档内容 */
  content: string
  /** 元数据 (JSON 字符串) */
  metadata?: string
  /** 分数 */
  score: number
}
/** 混合搜索结果 */
export interface HybridSearchResult {
  /** 文档 ID */
  id: string
  /** 文档内容 */
  content: string
  /** 元数据 (JSON 字符串) */
  metadata?: string
  /** 最终融合分数 */
  finalScore: number
  /** BM25 原始分数 */
  bm25Score: number
  /** BM25 排名 */
  bm25Rank?: number
  /** 向量搜索原始分数 */
  vectorScore: number
  /** 向量搜索排名 */
  vectorRank?: number
  /** TagMemo 增强分数 */
  tagBoostScore: number
  /** 来源 ("bm25", "vector", "both") */
  source: string
}
/** 混合搜索配置 */
export interface HybridSearchConfig {
  bm25Weight: number
  vectorWeight: number
  tagBoostWeight: number
  rrfK: number
}
/** 快速 RRF 融合 */
export declare function quickRrfFusion(bm25Results: Array<SearchResultItem>, vectorResults: Array<SearchResultItem>, limit?: number | undefined | null): Array<HybridSearchResult>
/** 计算 RRF 分数 */
export declare function computeRrfScore(rank: number, k?: number | undefined | null): number
/** 融合多个结果列表 (通用版本) */
export declare function multiSourceFusion(resultLists: Array<Array<SearchResultItem>>, weights: Array<number>, k?: number | undefined | null, limit?: number | undefined | null): Array<HybridSearchResult>
export interface SearchDocument {
  id: string
  title?: string
  content: string
  tags?: Array<string>
}
export interface SearchResult {
  id: string
  title?: string
  content: string
  tags?: Array<string>
  score: number
}
export interface SearchStats {
  documentCount: number
}
/** 语义组类型枚举 */
export const enum SemanticGroupType {
  /** 颜色 */
  Color = 'Color',
  /** 图案/花纹 */
  Pattern = 'Pattern',
  /** 廓形/版型 */
  Silhouette = 'Silhouette',
  /** 风格 */
  Style = 'Style',
  /** 材质 */
  Material = 'Material',
  /** 场合 */
  Occasion = 'Occasion',
  /** 季节 */
  Season = 'Season',
  /** 自定义 */
  Custom = 'Custom'
}
/** 语义组匹配结果 */
export interface SemanticGroupMatch {
  /** 组类型 */
  groupType: string
  /** 子组名称 */
  subGroup: string
  /** 匹配到的关键词 */
  matchedKeywords: Array<string>
  /** 匹配权重 (0-1) */
  weight: number
}
/** 语义组关键词定义 */
export interface GroupKeywords {
  /** 组类型 */
  groupType: string
  /** 子组名称 */
  subGroup: string
  /** 关键词列表 */
  keywords: Array<string>
}
/** 标签对更新 */
export interface TagPairUpdate {
  tag1: string
  tag2: string
  weight?: number
}
/** 标签关联结果 */
export interface TagAssociation {
  tag: string
  pmi: number
  cooccurrence: number
  frequency: number
}
/** 矩阵统计信息 */
export interface TagMatrixStats {
  tagCount: number
  pairCount: number
  totalUpdates: number
  alpha: number
  beta: number
}
/** 标签增强参数 */
export interface TagBoostParams {
  /** 查询标签列表 */
  queryTags: Array<string>
  /** 内容标签列表 */
  contentTags: Array<string>
  /** 原始分数 (可选) */
  originalScore?: number
  /** Alpha 最小值 (默认 1.5) */
  alphaMin?: number
  /** Alpha 最大值 (默认 3.5) */
  alphaMax?: number
  /** Beta 基础值 */
  betaBase?: number
}
/** 标签增强结果 */
export interface TagBoostResult {
  /** 原始分数 */
  originalScore: number
  /** 增强后分数 */
  boostedScore: number
  /** 直接匹配的标签 */
  matchedTags: Array<string>
  /** 扩展匹配的标签 */
  expansionTags: Array<string>
  /** 增强因子 */
  boostFactor: number
  /** 标签匹配总分 */
  tagMatchScore: number
  /** 详细的 spike 计算信息 */
  spikeDetails: Array<SpikeDetail>
  /** 动态 Alpha */
  dynamicAlpha: number
  /** 动态 Beta */
  dynamicBeta: number
}
/** Spike 计算详情 */
export interface SpikeDetail {
  /** 标签名 */
  tag: string
  /** 共现权重 */
  weight: number
  /** 全局频率 */
  globalFreq: number
  /** 计算得分 */
  score: number
}
/** 批量增强项 */
export interface TagBoostBatchItem {
  /** 内容标签 */
  contentTags: Array<string>
  /** 原始分数 */
  originalScore?: number
}
/** 向量增强参数 */
export interface VectorBoostParams {
  /** 原始向量 */
  originalVector: Array<number>
  /** 查询标签列表 */
  queryTags: Array<string>
  /** 内容标签列表 */
  contentTags: Array<string>
  /**
   * 标签对应的上下文向量 (tag -> vector 的扁平化表示)
   * 格式: [tag1_dim0, tag1_dim1, ..., tag2_dim0, tag2_dim1, ...]
   */
  tagVectors?: Array<number>
  /** 标签名列表 (与 tag_vectors 对应) */
  tagNames?: Array<string>
  /** 向量维度 */
  vectorDim: number
  /** Alpha 最小值 (默认 1.5) */
  alphaMin?: number
  /** Alpha 最大值 (默认 3.5) */
  alphaMax?: number
  /** Beta 基础值 (默认 2.0) */
  betaBase?: number
  /** 最大增强比例 (默认 0.3, 即最多 30% 上下文融合) */
  maxBoostRatio?: number
}
/** 向量增强结果 */
export interface VectorBoostResult {
  /** 融合后的向量 */
  fusedVector: Array<number>
  /** 原始分数 */
  originalScore: number
  /** 增强后分数 */
  boostedScore: number
  /** 直接匹配的标签 */
  matchedTags: Array<string>
  /** 扩展匹配的标签 */
  expansionTags: Array<string>
  /** 增强因子 (1.0 表示无增强) */
  boostFactor: number
  /** 上下文融合比例 (0-1) */
  contextBlendRatio: number
  /** 动态 Alpha */
  dynamicAlpha: number
  /** 动态 Beta */
  dynamicBeta: number
}
/** 设置日志回调（用于发送到 Node.js） */
export declare function setLogCallback(callback: (...args: any[]) => any): void
/** 日志条目 */
export interface LogEntry {
  timestamp: string
  level: string
  target: string
  message: string
  fields?: string
  span?: string
}
/** 创建 Trace ID */
export declare function createTraceId(): string
/** 创建 Span ID */
export declare function createSpanId(): string
/** Span 信息 */
export interface SpanInfo {
  spanId: string
  parentSpanId?: string
  operation: string
  startTime: string
  endTime?: string
  durationMs?: number
  status: string
  metadata?: string
}
/** 计算余弦相似度 */
export declare function cosineSimilarity(a: Array<number>, b: Array<number>): number
/** 计算欧氏距离 */
export declare function euclideanDistance(a: Array<number>, b: Array<number>): number
/** 计算点积 */
export declare function dotProduct(a: Array<number>, b: Array<number>): number
/** 向量归一化 */
export declare function normalize(v: Array<number>): Array<number>
/** 批量余弦相似度计算 */
export declare function batchCosineSimilarity(query: Array<number>, vectors: Array<Array<number>>): Array<number>
/** 批量计算并返回 Top-K */
export declare function topKSimilar(query: Array<number>, vectors: Array<Array<number>>, k: number): Array<SimilarityResult>
/** 相似度结果 */
export interface SimilarityResult {
  index: number
  score: number
}
export interface VectorEntry {
  id: string
  vector: Array<number>
}
export interface VectorSearchResult {
  id: string
  score: number
}
/** 向量搜索结果 */
export interface VexusSearchResult {
  /** 向量 ID（对应 SQLite 中的记录 ID） */
  id: number
  /** 相似度分数 (0-1, 1 表示完全匹配) */
  score: number
}
/** 索引统计信息 */
export interface VexusStats {
  /** 当前向量总数 */
  totalVectors: number
  /** 向量维度 */
  dimensions: number
  /** 当前容量 */
  capacity: number
  /** 内存使用量 (字节) */
  memoryUsage: number
}
/** 模块版本 */
export declare function getVersion(): string
/** 初始化原生模块 */
export declare function initialize(config: NativeVCPConfig): void
/** 原生模块配置 */
export interface NativeVcpConfig {
  /** 数据目录 */
  dataDir: string
  /** 日志级别 (trace, debug, info, warn, error) */
  logLevel?: string
  /** 是否启用全文搜索 */
  enableSearch?: boolean
  /** 向量维度 */
  vectorDim?: number
}
/** 健康检查 */
export declare function healthCheck(): HealthStatus
export interface HealthStatus {
  status: string
  version: string
  features: Array<string>
}
/**
 * 中文搜索引擎
 *
 * 使用 jieba-rs 进行中文分词，Tantivy 进行全文索引。
 * 支持中英文混合搜索。
 */
export declare class ChineseSearchEngine {
  /**
   * 创建或打开中文搜索引擎
   *
   * @param path - 索引存储路径
   */
  static open(path: string): ChineseSearchEngine
  /**
   * 添加文档
   *
   * @param doc - 要添加的文档
   */
  addDocument(doc: ChineseSearchDocument): void
  /** 批量添加文档 */
  addDocuments(docs: Array<ChineseSearchDocument>): number
  /** 更新文档（先删除再添加） */
  updateDocument(doc: ChineseSearchDocument): void
  /** 删除文档 */
  deleteDocument(id: string): void
  /** 提交更改 */
  commit(): void
  /**
   * 搜索
   *
   * @param query - 搜索查询
   * @param limit - 返回数量限制（默认 10）
   * @param fields - 搜索字段（可选，默认搜索 title 和 content）
   */
  search(query: string, limit?: number | undefined | null, fields?: Array<string> | undefined | null): Array<ChineseSearchResult>
  /**
   * 使用 jieba 分词
   *
   * @param text - 要分词的文本
   * @param search_mode - 是否使用搜索模式（默认 true）
   */
  tokenize(text: string, searchMode?: boolean | undefined | null): Array<string>
  /**
   * 提取关键词
   *
   * @param text - 要提取关键词的文本
   * @param top_k - 返回的关键词数量
   */
  extractKeywords(text: string, topK?: number | undefined | null): Array<KeywordResult>
  /** 获取统计信息 */
  getStats(): ChineseSearchStats
  /** 清空索引 */
  clear(): void
}
/** 文本分块器 */
export declare class TextChunker {
  /**
   * 创建文本分块器
   *
   * @param max_chunk_size - 最大 chunk 大小 (字符数，默认 1000)
   * @param overlap_size - 重叠大小 (字符数，默认 200)
   */
  constructor(maxChunkSize?: number | undefined | null, overlapSize?: number | undefined | null)
  /** 设置自定义分隔符 */
  setSeparators(separators: Array<string>): void
  /**
   * 分块文本
   *
   * @param text - 要分块的文本
   * @returns 分块结果列表
   */
  chunk(text: string): Array<TextChunk>
  /** 批量分块 */
  chunkBatch(texts: Array<string>): Array<ChunkBatchResult>
  /**
   * 估算 token 数量 (粗略估算)
   *
   * 中文约 1.5 字符/token，英文约 4 字符/token
   */
  estimateTokens(text: string): number
  /**
   * 按 token 数量分块
   *
   * @param text - 文本
   * @param max_tokens - 最大 token 数
   * @param overlap_tokens - 重叠 token 数
   */
  chunkByTokens(text: string, maxTokens?: number | undefined | null, overlapTokens?: number | undefined | null): Array<TextChunk>
  /** 获取分块器配置 */
  getConfig(): ChunkerConfig
}
/**
 * 共现矩阵核心结构
 *
 * 使用 NPMI (Normalized Pointwise Mutual Information) 计算标签关联度。
 * 支持高效的关联查询和多跳扩展。
 */
export declare class CooccurrenceMatrix {
  /** 创建空的共现矩阵 */
  constructor()
  /**
   * 从文档列表构建共现矩阵
   *
   * 使用 NPMI (Normalized PMI) 计算权重，自动处理所有标签对的关联度。
   *
   * @param documents - 文档列表，每个文档包含 id 和 tags
   * @returns 创建的共现关系数量
   */
  buildFromDocuments(documents: Array<DocumentInput>): number
  /**
   * 获取两个标签之间的共现权重
   *
   * @param tag1 - 第一个标签
   * @param tag2 - 第二个标签
   * @returns 共现权重 (0-1)，不存在返回 0
   */
  getCooccurrence(tag1: string, tag2: string): number
  /**
   * 获取与给定标签最相关的标签
   *
   * @param tag - 目标标签
   * @param top_k - 返回数量（默认 10）
   * @param min_weight - 最小权重阈值（默认 0.1）
   */
  getRelatedTags(tag: string, topK?: number | undefined | null, minWeight?: number | undefined | null): Array<TagCooccurrence>
  /**
   * 多跳标签扩展（BFS）
   *
   * 从种子标签出发，沿共现关系进行多跳扩展，用于查询扩展。
   *
   * @param seeds - 种子标签列表
   * @param depth - 最大扩展深度（默认 2）
   * @param decay_factor - 衰减因子（默认 0.7）
   */
  expandTags(seeds: Array<string>, depth?: number | undefined | null, decayFactor?: number | undefined | null): Array<TagCooccurrence>
  /**
   * 计算 TagMemo 增强权重
   *
   * 基于 PMI 共现矩阵计算标签增强权重，用于搜索结果排序。
   * 算法: alpha * exp(sum(cooccurrence)) + beta * log(1 + tag_count)
   *
   * @param query_tags - 查询中的标签
   * @param result_tags - 结果中的标签
   * @param alpha - 指数增强系数（默认 0.3）
   * @param beta - 对数降噪系数（默认 0.1）
   */
  calculateBoost(queryTags: Array<string>, resultTags: Array<string>, alpha?: number | undefined | null, beta?: number | undefined | null): number
  /** 获取所有标签 */
  getAllTags(): Array<string>
  /** 获取标签数量 */
  tagCount(): number
  /** 获取标签信息 */
  getTagInfo(tag: string): TagInfo | null
  /** 序列化为 JSON 字符串（用于持久化） */
  toJson(): string
  /** 从 JSON 字符串加载（用于恢复） */
  static fromJson(jsonStr: string): CooccurrenceMatrix
}
/** 统一数据库 */
export declare class UnifiedDatabase {
  /** 打开或创建数据库 */
  static open(path: string): UnifiedDatabase
  /** 保存记忆 */
  saveMemory(memory: MemoryRecord): void
  /** 搜索记忆 */
  searchMemories(query: MemoryQuery): Array<MemoryRecord>
  /** 记录追踪日志 */
  logTrace(log: TraceLog): void
  /** 查询追踪日志 */
  queryTraces(query: TraceQuery): Array<TraceLog>
  /** 获取数据库统计 */
  getStats(): DatabaseStats
  /** 执行 VACUUM */
  vacuum(): void
  /** 保存日记 */
  saveDiary(diary: DiaryRecord): void
  /** 获取日记 */
  getDiary(id: string): DiaryRecord | null
  /** 删除日记 */
  deleteDiary(id: string): boolean
  /** 按日期范围查询日记 */
  queryDiaryByDateRange(query: DiaryDateQuery): Array<DiaryRecord>
  /** 搜索日记 (全文搜索) */
  searchDiary(query: DiarySearchQuery): Array<DiaryRecord>
  /** 按标签查询日记 */
  queryDiaryByTags(tags: Array<string>, limit?: number | undefined | null): Array<DiaryRecord>
  /** 列出所有日记本 */
  listDiaryBooks(): Array<DiaryBookInfo>
  /** 获取日记统计信息 */
  getDiaryStats(bookName?: string | undefined | null): DiaryStats
  /** 批量保存日记 */
  batchSaveDiary(diaries: Array<DiaryRecord>): number
  /** 保存调度任务 */
  saveScheduledTask(task: ScheduledTask): void
  /** 获取调度任务 */
  getScheduledTask(id: string): ScheduledTask | null
  /** 删除调度任务 */
  deleteScheduledTask(id: string): boolean
  /** 列出所有调度任务 */
  listScheduledTasks(enabledOnly?: boolean | undefined | null): Array<ScheduledTask>
  /** 启用/禁用调度任务 */
  setTaskEnabled(id: string, enabled: boolean): boolean
  /** 按类型查询调度任务 */
  getTasksByType(taskType: string): Array<ScheduledTask>
  /** 记录任务执行开始 */
  logTaskStart(taskId: string, taskName: string): number
  /** 记录任务执行完成 */
  logTaskComplete(logId: number, result: string | undefined | null, durationMs: number): void
  /** 记录任务执行失败 */
  logTaskError(logId: number, error: string, durationMs: number, retryCount: number): void
  /** 查询任务执行日志 */
  queryTaskLogs(query: TaskLogQuery): Array<TaskExecutionLog>
  /** 获取任务执行统计 */
  getTaskStats(taskId?: string | undefined | null): TaskStats
  /** 清理旧的执行日志 */
  cleanupOldTaskLogs(daysToKeep: number): number
}
/**
 * 混合搜索引擎
 *
 * 融合 BM25 全文搜索和向量相似度搜索的结果
 */
export declare class HybridSearchEngine {
  /**
   * 创建混合搜索引擎
   *
   * @param bm25_weight - BM25 权重 (默认 0.5)
   * @param vector_weight - 向量搜索权重 (默认 0.5)
   * @param tag_boost_weight - TagMemo 增强权重 (默认 0.2)
   */
  constructor(bm25Weight?: number | undefined | null, vectorWeight?: number | undefined | null, tagBoostWeight?: number | undefined | null)
  /** 设置 RRF 常数 k */
  setRrfK(k: number): void
  /** 设置权重 */
  setWeights(bm25: number, vector: number, tagBoost: number): void
  /**
   * 融合搜索结果
   *
   * 使用 Reciprocal Rank Fusion (RRF) 算法融合多个搜索结果列表
   *
   * @param bm25_results - BM25 搜索结果 (按相关性排序)
   * @param vector_results - 向量搜索结果 (按相似度排序)
   * @param tag_boost_scores - TagMemo 增强分数 (可选，id -> score)
   * @param limit - 返回结果数量限制
   */
  fuseResults(bm25Results: Array<SearchResultItem>, vectorResults: Array<SearchResultItem>, tagBoostScores?: Record<string, number> | undefined | null, limit?: number | undefined | null): Array<HybridSearchResult>
  /**
   * 简单加权融合
   *
   * 直接使用分数加权平均，适用于已归一化的分数
   */
  weightedFusion(bm25Results: Array<SearchResultItem>, vectorResults: Array<SearchResultItem>, limit?: number | undefined | null): Array<HybridSearchResult>
  /** 获取配置 */
  getConfig(): HybridSearchConfig
  /** 归一化分数到 [0, 1] 区间 */
  normalizeScores(results: Array<SearchResultItem>): Array<SearchResultItem>
}
/** 全文搜索引擎 */
export declare class SearchEngine {
  /** 创建或打开搜索引擎 */
  static open(path: string): SearchEngine
  /** 添加文档 */
  addDocument(doc: SearchDocument): void
  /** 批量添加文档 */
  addDocuments(docs: Array<SearchDocument>): number
  /** 删除文档 */
  deleteDocument(id: string): void
  /** 提交更改 */
  commit(): void
  /** 搜索 */
  search(query: string, limit?: number | undefined | null): Array<SearchResult>
  /** 获取统计信息 */
  getStats(): SearchStats
}
/**
 * 语义组匹配器
 *
 * 用于快速查找文本中的语义关键词并进行分组。
 * 支持多语言关键词和同义词扩展。
 */
export declare class SemanticGroupMatcher {
  /** 创建空的匹配器 */
  constructor()
  /** 创建带有默认服装语义组的匹配器 */
  static withFashionGroups(): SemanticGroupMatcher
  /**
   * 注册一个语义组
   *
   * @param group_type - 组类型（如 "color", "pattern"）
   * @param sub_group - 子组名称（如 "warm", "cool"）
   * @param keywords - 关键词列表
   */
  registerGroup(groupType: string, subGroup: string, keywords: Array<string>): void
  /** 批量注册语义组 */
  registerGroups(groups: Array<GroupKeywords>): void
  /**
   * 从文本中提取匹配的语义组
   *
   * @param text - 要匹配的文本
   * @returns 匹配到的语义组列表
   */
  extractMatches(text: string): Array<SemanticGroupMatch>
  /**
   * 获取同组的扩展关键词
   *
   * 根据匹配结果，返回同一子组内未匹配的其他关键词。
   * 用于查询扩展。
   */
  expandKeywords(matches: Array<SemanticGroupMatch>): Array<string>
  /**
   * 计算两组匹配的重叠分数
   *
   * 用于比较查询和结果的语义相似度。
   *
   * @param query_matches - 查询的匹配结果
   * @param result_matches - 结果的匹配结果
   * @returns 重叠分数 (0-1)
   */
  calculateOverlap(queryMatches: Array<SemanticGroupMatch>, resultMatches: Array<SemanticGroupMatch>): number
  /**
   * 获取某组的所有关键词
   *
   * @param group_type - 组类型
   * @param sub_group - 子组名称（可选，不指定则返回所有子组的关键词）
   */
  getGroupKeywords(groupType: string, subGroup?: string | undefined | null): Array<string>
  /** 获取已注册的关键词数量 */
  keywordCount(): number
  /** 获取所有组类型 */
  getGroupTypes(): Array<string>
  /** 获取某个组类型的所有子组 */
  getSubGroups(groupType: string): Array<string>
  /** 检查关键词是否存在 */
  hasKeyword(keyword: string): boolean
  /** 获取关键词所属的组信息 */
  getKeywordGroup(keyword: string): GroupKeywords | null
}
/** 标签共现矩阵 */
export declare class TagCooccurrenceMatrix {
  /** 创建新的标签共现矩阵 */
  constructor(alpha?: number | undefined | null, beta?: number | undefined | null)
  /** 更新共现 */
  update(tag1: string, tag2: string, weight?: number | undefined | null): void
  /** 批量更新（高性能） */
  batchUpdate(updates: Array<TagPairUpdate>): void
  /** 计算 PMI（点互信息） */
  computePmi(tag1: string, tag2: string): number
  /** 获取关联标签（按 PMI 排序） */
  getAssociations(tag: string, topK?: number | undefined | null): Array<TagAssociation>
  /** 指数增强查询扩展 */
  expandQuery(tags: Array<string>, expansionFactor?: number | undefined | null): Array<string>
  /** 设置最小 PMI 阈值 */
  setMinPmiThreshold(threshold: number): void
  /** 获取统计信息 */
  getStats(): TagMatrixStats
  /** 序列化为 JSON */
  toJson(): string
  /** 从 JSON 加载 */
  static fromJson(json: string): TagCooccurrenceMatrix
  /** 清空矩阵 */
  clear(): void
  /**
   * 计算标签增强分数
   *
   * 核心算法来源: VCPToolBox _applyTagBoost
   * - 动态 Alpha: 基于平均标签得分调整增强强度 [1.5, 3.5]
   * - 动态 Beta: 模糊查询时提高降噪常数
   * - 指数级毛刺增强 + 对数级降噪
   */
  computeTagBoost(params: TagBoostParams): TagBoostResult
  /** 批量计算标签增强 */
  batchComputeTagBoost(items: Array<TagBoostBatchItem>, queryTags: Array<string>, alphaMin?: number | undefined | null, alphaMax?: number | undefined | null, betaBase?: number | undefined | null): Array<TagBoostResult>
  /**
   * 向量级标签增强
   *
   * 完整实现 VCPToolBox _applyTagBoost 的向量融合算法：
   * 1. 计算动态 Alpha/Beta
   * 2. 标签索引召回 + 共现扩展
   * 3. 构建上下文向量
   * 4. 线性融合: fused = (1-ratio)*original + ratio*context
   * 5. L2 归一化
   */
  boostVector(params: VectorBoostParams): VectorBoostResult
  /** 批量向量增强 */
  batchBoostVectors(originalVectors: Array<Array<number>>, queryTags: Array<string>, contentTagsList: Array<Array<string>>, tagVectors: Array<number> | undefined | null, tagNames: Array<string> | undefined | null, vectorDim: number, alphaMin?: number | undefined | null, alphaMax?: number | undefined | null, betaBase?: number | undefined | null, maxBoostRatio?: number | undefined | null): Array<VectorBoostResult>
}
/** 全链路追踪器 */
export declare class Tracer {
  /** 创建新的追踪器 */
  constructor(traceId?: string | undefined | null)
  /** 获取 Trace ID */
  getTraceId(): string
  /** 开始一个 Span */
  startSpan(operation: string, parentSpanId?: string | undefined | null): string
  /** 结束一个 Span */
  endSpan(spanId: string, status?: string | undefined | null, metadata?: string | undefined | null): void
  /** 记录事件 */
  logEvent(spanId: string | undefined | null, level: string, message: string, metadata?: string | undefined | null): void
  /** 获取所有 Spans */
  getSpans(): Array<SpanInfo>
  /** 导出为 JSON */
  toJson(): string
}
/** 向量存储（内存中） */
export declare class VectorStore {
  /** 创建向量存储 */
  constructor(dim: number)
  /** 添加向量 */
  add(id: string, vector: Array<number>): void
  /** 批量添加 */
  addBatch(entries: Array<VectorEntry>): number
  /** 搜索相似向量 */
  search(query: Array<number>, k: number): Array<VectorSearchResult>
  /** 获取存储大小 */
  size(): number
  /** 清空存储 */
  clear(): void
}
/**
 * HNSW 向量索引
 *
 * 基于 usearch 库实现的高性能向量索引，使用 HNSW 算法。
 * 支持余弦相似度、L2 距离等多种度量方式。
 */
export declare class VexusIndex {
  /**
   * 创建新的空索引
   *
   * @param dim - 向量维度
   * @param capacity - 初始容量（建议设置为预期向量数的 1.5 倍）
   */
  constructor(dim: number, capacity: number)
  /**
   * 从磁盘加载索引
   *
   * @param index_path - 索引文件路径
   * @param dim - 向量维度
   * @param capacity - 初始容量
   */
  static load(indexPath: string, dim: number, capacity: number): VexusIndex
  /**
   * 保存索引到磁盘
   *
   * 使用原子写入：先写临时文件，再重命名
   */
  save(indexPath: string): void
  /**
   * 添加单个向量
   *
   * @param id - 向量唯一 ID
   * @param vector - 向量数据（Float32 Buffer）
   */
  add(id: number, vector: Buffer): void
  /**
   * 批量添加向量
   *
   * @param ids - 向量 ID 列表
   * @param vectors - 连续的向量数据（所有向量拼接成一个 Buffer）
   */
  addBatch(ids: Array<number>, vectors: Buffer): void
  /**
   * 向量搜索
   *
   * @param query - 查询向量（Float32 Buffer）
   * @param k - 返回的最近邻数量
   */
  search(query: Buffer, k: number): Array<VexusSearchResult>
  /** 删除向量 */
  remove(id: number): void
  /** 获取索引统计信息 */
  stats(): VexusStats
  /**
   * 从 SQLite 恢复索引（异步）
   *
   * @param db_path - SQLite 数据库路径
   * @param table_name - 表名（如 "memories", "chunks"）
   * @param vector_column - 向量列名（默认 "embedding"）
   */
  recoverFromSqlite(dbPath: string, tableName: string, vectorColumn?: string | undefined | null): Promise<unknown>
  /** 检查向量是否存在 */
  contains(id: number): boolean
  /** 获取当前向量数量 */
  size(): number
}
